<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Tarefa3_2022li1g030</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption empty">&nbsp;</span><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>Ana S&#225; Oliveira &lt;a104437@alunos.uminho.pt&gt;<br />Sara Campos Ramalho &lt;a72481@alunos.uminho.pt&gt;</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr></table><p class="caption">Tarefa3_2022li1g030</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Fun&#231;&#227;o animaJogo</a><ul><li><a href="#g:2">Fun&#231;&#227;o principal</a></li><li><a href="#g:3">Fun&#231;&#245;es auxiliares</a></li></ul></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>M&#243;dulo para a realiza&#231;&#227;o da Tarefa 3 do projeto de LI1 em 2022/23.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:animaJogo">animaJogo</a> :: <a href="LI12223.html#t:Jogo" title="LI12223">Jogo</a> -&gt; <a href="LI12223.html#t:Jogada" title="LI12223">Jogada</a> -&gt; <a href="LI12223.html#t:Jogo" title="LI12223">Jogo</a></li><li class="src short"><a href="#v:ordenada">ordenada</a> :: <a href="LI12223.html#t:Jogo" title="LI12223">Jogo</a> -&gt; Int</li><li class="src short"><a href="#v:movObstaculos">movObstaculos</a> :: Int -&gt; (<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>]) -&gt; (<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>])</li><li class="src short"><a href="#v:animaLista">animaLista</a> :: [(<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>])] -&gt; [(<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>])]</li><li class="src short"><a href="#v:animaMapa">animaMapa</a> :: <a href="LI12223.html#t:Jogo" title="LI12223">Jogo</a> -&gt; <a href="LI12223.html#t:Jogo" title="LI12223">Jogo</a></li><li class="src short"><a href="#v:posicaoInicial">posicaoInicial</a> :: <a href="LI12223.html#t:Jogo" title="LI12223">Jogo</a> -&gt; (<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, <a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>)</li><li class="src short"><a href="#v:posicaoFinal">posicaoFinal</a> :: <a href="LI12223.html#t:Jogo" title="LI12223">Jogo</a> -&gt; (<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, <a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>) -&gt; <a href="LI12223.html#t:Jogo" title="LI12223">Jogo</a></li><li class="src short"><a href="#v:animaJogador">animaJogador</a> :: <a href="LI12223.html#t:Jogo" title="LI12223">Jogo</a> -&gt; <a href="LI12223.html#t:Jogada" title="LI12223">Jogada</a> -&gt; <a href="LI12223.html#t:Jogo" title="LI12223">Jogo</a></li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Fun&#231;&#227;o animaJogo</h1></a><a href="#g:2" id="g:2"><h2>Fun&#231;&#227;o principal</h2></a><div class="top"><p class="src"><a id="v:animaJogo" class="def">animaJogo</a> :: <a href="LI12223.html#t:Jogo" title="LI12223">Jogo</a> -&gt; <a href="LI12223.html#t:Jogada" title="LI12223">Jogada</a> -&gt; <a href="LI12223.html#t:Jogo" title="LI12223">Jogo</a> <a href="#v:animaJogo" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:animaJogo" title="Tarefa3_2022li1g030">animaJogo</a></code>, que recebe um jogo e uma jogada e que retorna um jogo, movimenta os obst&#225;culos, de acordo com a velocidade do terreno em que se encontram, e o personagem, de 
acordo com a jogada dada.</p><p>A fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:animaJogo" title="Tarefa3_2022li1g030">animaJogo</a></code> pode ser definida em fun&#231;&#227;o de outras fun&#231;&#245;es auxiliares: a fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:ordenada" title="Tarefa3_2022li1g030">ordenada</a></code>, a fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:animaMapa" title="Tarefa3_2022li1g030">animaMapa</a></code>, a fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:posicaoInicial" title="Tarefa3_2022li1g030">posicaoInicial</a></code>, a fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:posicaoFinal" title="Tarefa3_2022li1g030">posicaoFinal</a></code> e a fun&#231;&#227;o 
<code><a href="Tarefa3_2022li1g030.html#v:animaJogador" title="Tarefa3_2022li1g030">animaJogador</a></code>. A fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:animaMapa" title="Tarefa3_2022li1g030">animaMapa</a></code> cont&#233;m ainda outra fun&#231;&#227;o auxiliar, a fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:animaLista" title="Tarefa3_2022li1g030">animaLista</a></code> que por sua vez cont&#233;m outra fun&#231;&#227;o auxiliar, a fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:movObstaculos" title="Tarefa3_2022li1g030">movObstaculos</a></code>.</p><p>Assim, a fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:animaJogo" title="Tarefa3_2022li1g030">animaJogo</a></code> pode ser definida da seguinte forma:</p><pre>animaJogo (Jogo (Jogador (x,y)) (Mapa n l)) j | y == ordenada (animaJogador (Jogo (Jogador (x,y)) (Mapa n l)) j) = (posicaoFinal ((animaMapa (animaJogador (Jogo (Jogador (x,y)) (Mapa n l)) j))) (posicaoInicial (Jogo (Jogador (x,y)) (Mapa n l))))
                                              | otherwise = animaMapa (animaJogador (Jogo (Jogador (x,y)) (Mapa n l)) j)
</pre></div></div><a href="#g:3" id="g:3"><h2>Fun&#231;&#245;es auxiliares</h2></a><div class="top"><p class="src"><a id="v:ordenada" class="def">ordenada</a> :: <a href="LI12223.html#t:Jogo" title="LI12223">Jogo</a> -&gt; Int <a href="#v:ordenada" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:ordenada" title="Tarefa3_2022li1g030">ordenada</a></code>, que recebe um jogo e retorna um n&#250;mero inteiro, descobre qual &#233; a ordenada de um jogador num determinado jogo. Esta fun&#231;&#227;o &#233; utilizada na fun&#231;&#227;o principal para 
percebermos se o jogador se movimentou horizontalmente ou verticalmente. Se o y inicial do jogador for igual ao y final do jogador ap&#243;s a fun&#231;&#227;o animaJogador, ou seja, ap&#243;s o seu
movimento, ent&#227;o significa que o jogador apenas se moveu na horizontal (ou ficou parado). Assim, se apenas se moveu na horizontal ent&#227;o existe a possibilidade de ele acompanhar o movimento 
de um suposto tronco, isto se o jogador inicialmente se encontrava num tronco. Esta hip&#243;tese ser&#225; confirmada ou rejeitada atr&#225;ves da fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:posicaoInicial" title="Tarefa3_2022li1g030">posicaoInicial</a></code>. Se o y inicial do jogador n&#227;o
for igual ao y final do jogador ap&#243;s a fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:animaJogador" title="Tarefa3_2022li1g030">animaJogador</a></code>, ou seja, ap&#243;s o seu movimento, ent&#227;o significa que o jogador se moveu verticalmente, logo o movimento dos troncos n&#227;o o poder&#225;
afetar.</p><p>Assim, a fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:ordenada" title="Tarefa3_2022li1g030">ordenada</a></code> pode ser definida da seguinte forma:</p><pre>ordenada (Jogo (Jogador (x,y)) (Mapa n l)) = y  
</pre></div></div><div class="top"><p class="src"><a id="v:movObstaculos" class="def">movObstaculos</a> :: Int -&gt; (<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>]) -&gt; (<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>]) <a href="#v:movObstaculos" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:movObstaculos" title="Tarefa3_2022li1g030">movObstaculos</a></code>, que recebe um inteiro e um par de terreno e de lista de obst&#225;culos e que retorna um par de terreno e de lista de obst&#225;culos, movimenta os obst&#225;culos de um 
rio ou estrada de acordo com a velocidade do terreno. Numa estrada ou rio com velocidade v, os obst&#225;culos devem mover-se |v| unidades na dire&#231;&#227;o determinada. Se a velocidade v for igual
a 0, os obst&#225;culos n&#227;o se movimentam, ou seja, a fun&#231;&#227;o ir&#225; retornar a mesma lista que recebeu, porque nada se alterou. Se a velocidade v for positiva, os obst&#225;culos movem-se |v| unidades
da esquerda para a direita. Se a velocidade v for negativa, os obst&#225;culos movem-se |v| unidades da direita para a esquerda. Sabemos que ao deslocar os obst&#225;culos de uma linha, estes 
desaparecerem por um dos lados do mapa e devem reaparecer no lado oposto. Assim, para mover os obst&#225;culos apenas temos de mudar a ordem da lista de obst&#225;culos. Quando a lista de obst&#225;culos
se move para a direita, quando a velocidade v &#233; positiva, pegamos nos ult&#237;mos v elementos da lista e os colocamos na frente da lista. Para fazer isto podemos usar as fun&#231;&#245;es last, init e
(!!) pr&#233;-definidas no Haskell. Quando a lista de obst&#225;culos se move para a esquerda, quando a velocidade v &#233; negativa, pegamos nos primeiros v elementos da lista e os colocamos atr&#225;s da 
lista. Para fazer isto podemos usar as fun&#231;&#245;es head, tail e (!!) pr&#233;-definidas no Haskell. </p><p>Assim, a fun&#231;&#227;o recursiva <code><a href="Tarefa3_2022li1g030.html#v:movObstaculos" title="Tarefa3_2022li1g030">movObstaculos</a></code> pode ser definida da seguinte forma:</p><pre>movObstaculos n (Rio v, []) = (Rio v, [])
movObstaculos n (Estrada v,[]) = (Estrada v, [])
movObstaculos n (Rio v,l) | n==0 = (Rio v,l)
                          | n&gt;0 = movObstaculos (n-1) (Rio v,[last l] ++ (init l))
                          | n&lt;0 = movObstaculos (n+1) (Rio v,(tail l) ++ [head l])
movObstaculos n (Estrada v,l) | n==0 = (Estrada v,l)
                              | n&gt;0 = movObstaculos (n-1) (Estrada v,[last l] ++ (init l))
                              | n&lt;0 = movObstaculos (n+1) (Estrada v,(tail l) ++ [head l])
</pre></div></div><div class="top"><p class="src"><a id="v:animaLista" class="def">animaLista</a> :: [(<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>])] -&gt; [(<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>])] <a href="#v:animaLista" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:animaLista" title="Tarefa3_2022li1g030">animaLista</a></code>, que recebe uma lista de pares de terreno e de lista de obst&#225;culos e que retorna uma lista de pares de terreno e de lista de obst&#225;culos, utiliza a fun&#231;&#227;o
anterior (<code><a href="Tarefa3_2022li1g030.html#v:movObstaculos" title="Tarefa3_2022li1g030">movObstaculos</a></code>) para obter as listas de obst&#225;culos dos rios e das estradas. J&#225; numa relva, n&#227;o existe velocidade e os obst&#225;culos n&#227;o se movimentam, ou seja, a fun&#231;&#227;o ir&#225;
retornar a mesmma lista que recebeu, porque nada se alterou. Para al&#233;m disso, se a fun&#231;&#227;o receber uma lista vazia ir&#225; retornar lista vazia, pois n&#227;o existem obst&#225;culos que se podem mover
(a lista vazia n&#227;o tem elementos logo n&#227;o tem obst&#225;culos).</p><p>Assim, a fun&#231;&#227;o recursiva <code><a href="Tarefa3_2022li1g030.html#v:animaLista" title="Tarefa3_2022li1g030">animaLista</a></code> pode ser definida da seguinte forma:</p><pre>animaLista ((Rio n,l):t) = [movObstaculos n (Rio n,l)] ++ (animaLista t)
animaLista ((Estrada n,l):t) = [movObstaculos n (Estrada n,l)] ++ (animaLista t)
animaLista ((Relva,l):t) = [(Relva,l)] ++ (animaLista t)
animaLista [] = []
</pre></div></div><div class="top"><p class="src"><a id="v:animaMapa" class="def">animaMapa</a> :: <a href="LI12223.html#t:Jogo" title="LI12223">Jogo</a> -&gt; <a href="LI12223.html#t:Jogo" title="LI12223">Jogo</a> <a href="#v:animaMapa" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:animaMapa" title="Tarefa3_2022li1g030">animaMapa</a></code>, que recebe um jogo e retorna um jogo, utiliza a fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:animaLista" title="Tarefa3_2022li1g030">animaLista</a></code> para mover os obst&#225;culos de todo o mapa do jogo.</p><p>Assim, a fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:animaMapa" title="Tarefa3_2022li1g030">animaMapa</a></code> pode ser definida da seguinte forma:</p><pre>animaMapa (Jogo (Jogador (x,y)) (Mapa n l)) = (Jogo (Jogador (x,y)) (Mapa n (animaLista l)))
</pre></div></div><div class="top"><p class="src"><a id="v:posicaoInicial" class="def">posicaoInicial</a> :: <a href="LI12223.html#t:Jogo" title="LI12223">Jogo</a> -&gt; (<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, <a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>) <a href="#v:posicaoInicial" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:posicaoInicial" title="Tarefa3_2022li1g030">posicaoInicial</a></code>, que recebe um jogo e retorna um par de terreno e de obst&#225;culo, pega num jogo e calcula o terreno e o obst&#225;culo onde o jogador se encontra naquele jogo. 
Para o fazer, utiliza a fun&#231;&#227;o (!!) pr&#233;-definida no Haskell.</p><p>Assim, a fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:posicaoInicial" title="Tarefa3_2022li1g030">posicaoInicial</a></code> pode ser definida da seguinte forma:</p><pre>posicaoInicial (Jogo (Jogador (x,y)) (Mapa n l)) = (fst (l !! y) , ((snd (l !! y)) !! x))
</pre></div></div><div class="top"><p class="src"><a id="v:posicaoFinal" class="def">posicaoFinal</a> :: <a href="LI12223.html#t:Jogo" title="LI12223">Jogo</a> -&gt; (<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, <a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>) -&gt; <a href="LI12223.html#t:Jogo" title="LI12223">Jogo</a> <a href="#v:posicaoFinal" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:posicaoFinal" title="Tarefa3_2022li1g030">posicaoFinal</a></code>, que recebe um jogo e um par de terreno e obst&#225;culo e retorna um jogo, calcula as pr&#243;ximas coordenadas do jogador, em fun&#231;&#227;o das coordenadas do jogador ap&#243;s as 
fun&#231;&#245;es <code><a href="Tarefa3_2022li1g030.html#v:animaMapa" title="Tarefa3_2022li1g030">animaMapa</a></code> e <code><a href="Tarefa3_2022li1g030.html#v:animaJogador" title="Tarefa3_2022li1g030">animaJogador</a></code> e em fun&#231;&#227;o do terreno e do obst&#225;culo em que o jogador se encontrava inicialmente. Se a fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:posicaoFinal" title="Tarefa3_2022li1g030">posicaoFinal</a></code> receber o par de terreno e de obst&#225;culo 
obtido pela fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:posicaoInicial" title="Tarefa3_2022li1g030">posicaoInicial</a></code> e se receber o mesmo jogo obtido pela fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:animaMapa" title="Tarefa3_2022li1g030">animaMapa</a></code> ao receber o jogo obtido pela fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:animaJogador" title="Tarefa3_2022li1g030">animaJogador</a></code>, ent&#227;o podemos calcular as pr&#243;ximas 
coordenadas do jogador, as coordenadas finais do jogador.</p><p>Mesmo quando o jogador n&#227;o efetua qualquer movimento (quando a sua jogada &#233; Parado), se o personagem se encontrar em cima de um tronco, o jogador acompanha o movimento do tronco. Assim,
se o jogador se encontrava num Rio com n velocidade e num Tronco, ent&#227;o o jogador mover-se-&#225; n unidades numa determinada dire&#231;&#227;o dependendo do valor de n. Assim, a abcissa do jogador 
passar&#225; de x para x+n. Se o jogador se encontrar num Rio e num Nenhum, ou se se encontrar noutro tipo de terreno, ent&#227;o o jogador n&#227;o se ir&#225; mover com o mapa, logo ir&#225; apresentar as mesmas 
coordenadas.</p><p>Assim, a fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:posicaoFinal" title="Tarefa3_2022li1g030">posicaoFinal</a></code> pode ser definida da seguinte forma:</p><pre>posicaoFinal (Jogo (Jogador (x,y)) (Mapa n l)) (Rio v,Tronco) = (Jogo (Jogador (x+v,y)) (Mapa n l))
posicaoFinal (Jogo (Jogador (x,y)) (Mapa n l)) (_,o) = (Jogo (Jogador (x,y)) (Mapa n l))
</pre></div></div><div class="top"><p class="src"><a id="v:animaJogador" class="def">animaJogador</a> :: <a href="LI12223.html#t:Jogo" title="LI12223">Jogo</a> -&gt; <a href="LI12223.html#t:Jogada" title="LI12223">Jogada</a> -&gt; <a href="LI12223.html#t:Jogo" title="LI12223">Jogo</a> <a href="#v:animaJogador" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:animaJogador" title="Tarefa3_2022li1g030">animaJogador</a></code>, que recebe um jogo e uma jogada e que retorna um jogo, movimenta um jogador num jogo. </p><p>Se a jogada for Parado ent&#227;o o jogo que retorna ser&#225; o mesmo que recebeu, uma vez que o jogador n&#227;o se moveu.</p><p>As jogadas Move Cima, Move Baixo, etc. fazem com que o jogador se mova 1 unidade para cima, baixo, etc, respectivamente. Se a jogada for Move Cima ent&#227;o a ordenada do jogador passar&#225; de y 
para y-1. Se a jogada for Move Baixo ent&#227;o a ordenada do jogador passar&#225; de y para y+1. Se a jogada for Move Esquerda ent&#227;o a abcissa do jogador passar&#225; de x para x-1. Se a jogada for Move
Direita ent&#227;o a abcissa do jogador passar&#225; de x para x+1. Isto acontece porque o canto superior esquerdo representa as coordenadas (0,0) e porque todas as posi&#231;&#245;es no mapa tem abcissas e 
ordenadas n&#227;o negativas (ou seja, positivas ou nulas).</p><p>No entanto, temos que ter em aten&#231;&#227;o que o jogador n&#227;o consegue escapar do mapa atrav&#233;s dos seus movimentos. Por exemplo, se o jogador se encontrar na linha de topo do mapa, ent&#227;o mover-se
para cima n&#227;o tem qualquer efeito, uma vez que j&#225; se encontra no limite do mapa. Assim, quando y for igual a 0 e quando a jogada for Move Cima, o jogador n&#227;o altera a sua posi&#231;&#227;o. Seguindo
o mesmo racioc&#237;nio, quando x for igual a 0 e a quando a jogada for Move Esquerda, o jogador n&#227;o altera a sua posi&#231;&#227;o. Quando x for igual &#225; largura do mapa menos uma unidade (porque 
come&#231;amos a contar do 0) e quando a jogada for Move Direita, o jogador n&#227;o altera a sua posi&#231;&#227;o. Quando o y for igual ao comprimento da lista total do mapa menos uma unidade (porque
come&#231;amos a contar do 0) e quando a jogada for Move Baixo, o jogador n&#227;o altera a sua posi&#231;&#227;o.</p><p>Por fim, ainda temos de ter em aten&#231;&#227;o que o jogador n&#227;o ocupa posi&#231;&#245;es onde existem Arvores. Ou seja, quando o jogador vai em dire&#231;&#227;o a uma Arvore, ele acaba por se manter na mesma 
posi&#231;&#227;o, uma vez que n&#227;o pode ocupar a posi&#231;&#227;o de uma Arvore. Assim, se uma Arvore se encontrar, por exemplo, em baixo do jogador, ou seja se 
posicaoInicial (Jogo (Jogador (x,y+1)) (Mapa n l)) resultar em (Relva,Arvore) e se a jogada for Move Baixo, ent&#227;o o jogador n&#227;o se ir&#225; mecher. Isto tamb&#233;m acontece quando tem uma Arvore em
cima, &#224; direita ou &#224; esquerda do jogador e quando a jogada &#233; respetivamente, Move Cima, Move Direita e Move Esquerda.</p><p>Assim, a fun&#231;&#227;o <code><a href="Tarefa3_2022li1g030.html#v:animaJogador" title="Tarefa3_2022li1g030">animaJogador</a></code> pode ser definida da seguinte forma:</p><pre>animaJogador (Jogo (Jogador (x,y)) (Mapa n l)) (Parado) = (Jogo (Jogador (x,y)) (Mapa n l))
animaJogador (Jogo (Jogador (x,y)) (Mapa n l)) (Move Cima) | y == 0 = (Jogo (Jogador (x,y)) (Mapa n l))
                                                           | posicaoInicial (Jogo (Jogador (x,y-1)) (Mapa n l)) == (Relva,Arvore) = (Jogo (Jogador (x,y)) (Mapa n l))
                                                           | otherwise = (Jogo (Jogador (x,y-1)) (Mapa n l))
animaJogador (Jogo (Jogador (x,y)) (Mapa n l)) (Move Baixo) | y == (length l) - 1 = (Jogo (Jogador (x,y)) (Mapa n l))
                                                            | posicaoInicial (Jogo (Jogador (x,y+1)) (Mapa n l)) == (Relva,Arvore) = (Jogo (Jogador (x,y)) (Mapa n l))
                                                            | otherwise = (Jogo (Jogador (x,y+1)) (Mapa n l))
animaJogador (Jogo (Jogador (x,y)) (Mapa n l)) (Move Esquerda) | x == 0 = (Jogo (Jogador (x,y)) (Mapa n l))
                                                               | posicaoInicial (Jogo (Jogador (x-1,y)) (Mapa n l)) == (Relva,Arvore) = (Jogo (Jogador (x,y)) (Mapa n l))
                                                               | otherwise = (Jogo (Jogador (x-1,y)) (Mapa n l))
animaJogador (Jogo (Jogador (x,y)) (Mapa n l)) (Move Direita) | x == (n-1) = (Jogo (Jogador (x,y)) (Mapa n l))
                                                              | posicaoInicial (Jogo (Jogador (x+1,y)) (Mapa n l)) == (Relva,Arvore) = (Jogo (Jogador (x,y)) (Mapa n l))
                                                              | otherwise = (Jogo (Jogador (x+1,y)) (Mapa n l))
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>