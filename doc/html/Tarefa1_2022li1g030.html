<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Tarefa1_2022li1g030</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption empty">&nbsp;</span><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>Ana S&#225; Oliveira &lt;a104437@alunos.uminho.pt&gt;<br />Sara Campos Ramalho &lt;a72481@alunos.uminho.pt&gt;</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr></table><p class="caption">Tarefa1_2022li1g030</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Fun&#231;&#227;o mapaValido</a><ul><li><a href="#g:2">Fun&#231;&#227;o principal</a></li><li><a href="#g:3">Fun&#231;&#245;es auxiliares</a></li></ul></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>M&#243;dulo para a realiza&#231;&#227;o da Tarefa 1 do projeto de LI1 em 2022/23.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:mapaValido">mapaValido</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool</li><li class="src short"><a href="#v:obstaculoTerrenoProprio">obstaculoTerrenoProprio</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool</li><li class="src short"><a href="#v:riosDirecaoOposta">riosDirecaoOposta</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool</li><li class="src short"><a href="#v:duplicarListaObstaculos">duplicarListaObstaculos</a> :: [(<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>])] -&gt; [(<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>])]</li><li class="src short"><a href="#v:mapaListaObstaculosDuplicados">mapaListaObstaculosDuplicados</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a></li><li class="src short"><a href="#v:compMaxObstaculos">compMaxObstaculos</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool</li><li class="src short"><a href="#v:umNenhumNoMinimo">umNenhumNoMinimo</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool</li><li class="src short"><a href="#v:larguraCompObstaculos">larguraCompObstaculos</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool</li><li class="src short"><a href="#v:maxTerrenoContiguo">maxTerrenoContiguo</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Fun&#231;&#227;o mapaValido</h1></a><a href="#g:2" id="g:2"><h2>Fun&#231;&#227;o principal</h2></a><div class="top"><p class="src"><a id="v:mapaValido" class="def">mapaValido</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool <a href="#v:mapaValido" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:mapaValido" title="Tarefa1_2022li1g030">mapaValido</a></code>, que recebe um mapa e retorna um bool, verifica se um dado mapa &#233; v&#225;lido, ou seja, se um dado mapa n&#227;o viola nenhuma das seguintes restri&#231;&#245;es:</p><ul><li>N&#227;o existem obst&#225;culos em terrenos impr&#243;prios (por exemplo, troncos em estradas ou relvas, &#225;rvores em rios ou estradas, etc.);</li><li>Rios cont&#237;guos t&#234;m dire&#231;&#245;es opostas;</li><li>Troncos t&#234;m, no m&#225;ximo, 5 unidades de comprimento;</li><li>Carros t&#234;m, no m&#225;ximo, 3 unidades de comprimento;</li><li>Em qualquer linha existe, no m&#237;nimo, um &#8220;obst&#225;culo&quot; Nenhum, ou seja, uma linha n&#227;o pode ser composta exclusivamente por obst&#225;culos, precisando de haver pelo menos um espa&#231;o livre;</li><li>O comprimento da lista de obst&#225;culos de cada linha corresponde exatamente &#224; largura do mapa;</li><li>Contiguamente, n&#227;o devem existir mais do que 4 rios, nem 5 estradas ou relvas.</li></ul><p>A fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:mapaValido" title="Tarefa1_2022li1g030">mapaValido</a></code> pode ser definida em fun&#231;&#227;o de outras fun&#231;&#245;es auxiliares: a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:obstaculoTerrenoProprio" title="Tarefa1_2022li1g030">obstaculoTerrenoProprio</a></code>, a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:riosDirecaoOposta" title="Tarefa1_2022li1g030">riosDirecaoOposta</a></code>, a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:compMaxObstaculos" title="Tarefa1_2022li1g030">compMaxObstaculos</a></code>, a fun&#231;&#227;o
<code><a href="Tarefa1_2022li1g030.html#v:umNenhumNoMinimo" title="Tarefa1_2022li1g030">umNenhumNoMinimo</a></code>, a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:larguraCompObstaculos" title="Tarefa1_2022li1g030">larguraCompObstaculos</a></code> e a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:maxTerrenoContiguo" title="Tarefa1_2022li1g030">maxTerrenoContiguo</a></code>, fun&#231;&#245;es que recebem um mapa e retornam um bool e que verificam as restri&#231;&#245;es anteriormente enunciadas. </p><p>Se uma destas fun&#231;&#245;es auxiliares retornar False, ou seja, se uma das restri&#231;&#245;es n&#227;o for respeitada, ent&#227;o automaticamente o mapa ser&#225; inv&#225;lido, ou seja, a fun&#231;&#227;o mapaValido ir&#225; retornar
False. Assim, para o mapa ser v&#225;lido, ou seja, para a fun&#231;&#227;o mapaValido retornar True, ent&#227;o todas as restri&#231;&#245;es ter&#227;o de ser respeitadas, logo todas as fun&#231;&#245;es auxiliares ter&#227;o de
retornar True.</p><p>Assim, a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:mapaValido" title="Tarefa1_2022li1g030">mapaValido</a></code> pode ser definida da seguinte forma:</p><pre>mapaValido (Mapa n l) = obstaculoTerrenoProprio (Mapa n l) &amp;&amp; riosDirecaoOposta (Mapa n l) &amp;&amp; compMaxObstaculos (mapaListaObstaculosDuplicados (Mapa n l)) &amp;&amp; umNenhumNoMinimo (Mapa n l) &amp;&amp; larguraCompObstaculos (Mapa n l) &amp;&amp; maxTerrenoContiguo (Mapa n l)
</pre><p>A fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:mapaValido" title="Tarefa1_2022li1g030">mapaValido</a></code> cont&#233;m ainda outra fun&#231;&#227;o auxiliar, a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:mapaListaObstaculosDuplicados" title="Tarefa1_2022li1g030">mapaListaObstaculosDuplicados</a></code> que por sua vez cont&#233;m outra fun&#231;&#227;o auxiliar, a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:duplicarListaObstaculos" title="Tarefa1_2022li1g030">duplicarListaObstaculos</a></code>.</p></div></div><a href="#g:3" id="g:3"><h2>Fun&#231;&#245;es auxiliares</h2></a><div class="top"><p class="src"><a id="v:obstaculoTerrenoProprio" class="def">obstaculoTerrenoProprio</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool <a href="#v:obstaculoTerrenoProprio" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:obstaculoTerrenoProprio" title="Tarefa1_2022li1g030">obstaculoTerrenoProprio</a></code>, que recebe um mapa e retorna um bool, verifica se num dado mapa n&#227;o existem obst&#225;culos em terrenos impr&#243;prios, ou seja, verifica que n&#227;o existem 
Troncos em Estradas ou Relvas, que n&#227;o existem Carros em Rios ou Relvas e que n&#227;o existem Arvores em Rios ou Estradas.</p><p>Esta fun&#231;&#227;o percorre toda a lista de obst&#225;culos &#225; procura de um obst&#225;culo impr&#243;prio para o terreno dado. Se encontrar um obst&#225;culo imp&#341;oprio para o terreno, a fun&#231;&#227;o retornara False. Se 
n&#227;o encontrar, ent&#227;o a fun&#231;&#227;o ir&#225; chamar a ela mesma (fun&#231;&#227;o recursiva) para procurar na pr&#243;xima lista de obst&#225;culos um obst&#225;culo impr&#243;prio para o terreno dado. Quando a fun&#231;&#227;o tiver 
percorrido todas as listas de obst&#225;culos do Mapa sem encontrar nenhum obst&#225;culo impr&#243;prio para o terreno dado e quando apenas sobrar a lista vazia, a fun&#231;&#227;o ir&#225; retornar True.</p><p>Assim, a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:obstaculoTerrenoProprio" title="Tarefa1_2022li1g030">obstaculoTerrenoProprio</a></code> pode ser definida da seguinte forma:</p><pre>obstaculoTerrenoProprio (Mapa n ((Rio n1,(h:t1)):t)) | h == Tronco || h == Nenhum = obstaculoTerrenoProprio (Mapa n ((Rio n1,t1):t))
                                                     | otherwise = False
obstaculoTerrenoProprio (Mapa n ((Estrada n1,(h:t1)):t)) | h == Carro || h == Nenhum = obstaculoTerrenoProprio (Mapa n ((Estrada n1,t1):t))
                                                         | otherwise = False
obstaculoTerrenoProprio (Mapa n ((Relva,(h:t1)):t)) | h == Arvore || h == Nenhum = obstaculoTerrenoProprio (Mapa n ((Relva,t1):t))
                                                    | otherwise = False
obstaculoTerrenoProprio (Mapa n ((_,[]):t)) = obstaculoTerrenoProprio (Mapa n t)
obstaculoTerrenoProprio (Mapa n []) = True
</pre></div></div><div class="top"><p class="src"><a id="v:riosDirecaoOposta" class="def">riosDirecaoOposta</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool <a href="#v:riosDirecaoOposta" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:riosDirecaoOposta" title="Tarefa1_2022li1g030">riosDirecaoOposta</a></code>, que recebe um mapa e retorna um bool, verifica se num dado mapa rios cont&#237;guos apresentam dire&#231;&#245;es opostas, ou seja, verifica se rios cont&#237;guos apresentam
velocidades de sinal oposto (por exemplo, o primeiro rio com velocidade positiva e o segundo rio cont&#237;guo ao primeiro com velocidade negativa ou vice-versa). Se isso n&#227;o se verificar, a 
fun&#231;&#227;o retorna False. Se isso se verificar, ent&#227;o a fun&#231;&#227;o ir&#225; chamar a ela mesma (fun&#231;&#227;o recursiva) para verificar se o segundo rio tem dire&#231;&#227;o oposta do terceiro ou se ap&#243;s o segundo rio
existe um terreno diferente de rio. Quando a fun&#231;&#227;o percorrer todo o mapa e n&#227;o encontrar nenhuns rios cont&#237;guos com dire&#231;&#245;es opostas e quando apenas sobrar a lista vazia ou uma lista de 
um elemento, a fun&#231;&#227;o ir&#225; retornar True.</p><p>Nota : iremos considerar que rios cont&#237;guos com velocidade igual a 0, ou rios cont&#237;guos em que apenas um tem velocidade igual a 0, s&#227;o rios de dire&#231;&#245;es opostas.</p><p>Assim, a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:riosDirecaoOposta" title="Tarefa1_2022li1g030">riosDirecaoOposta</a></code> pode ser definida da seguinte forma:</p><pre>riosDirecaoOposta (Mapa n ((Rio n1,t1):(Rio n2,t2):t)) | n1&gt;=0 &amp;&amp; n2&lt;=0 = riosDirecaoOposta (Mapa n ((Rio n2,t2):t))
                                                       | n1<a href="=0">&amp;&amp; n2</a>=0 = riosDirecaoOposta (Mapa n ((Rio n2,t2):t))
                                                       | otherwise = False 
riosDirecaoOposta (Mapa n ((_,t1):(Rio n2,t2):t)) = riosDirecaoOposta (Mapa n ((Rio n2,t2):t))
riosDirecaoOposta (Mapa n ((_,t1):(_,t2):t)) = riosDirecaoOposta (Mapa n t)
riosDirecaoOposta (Mapa n [(_,t1)]) = True
riosDirecaoOposta (Mapa n []) = True
</pre></div></div><div class="top"><p class="src"><a id="v:duplicarListaObstaculos" class="def">duplicarListaObstaculos</a> :: [(<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>])] -&gt; [(<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>])] <a href="#v:duplicarListaObstaculos" class="selflink">#</a></p><div class="doc"><p>Queremos verificar se num dado mapa os troncos t&#234;m comprimento m&#225;ximo de 5 unidades e os carros t&#234;m comprimento m&#225;ximo de 3 unidades. Como no terreno Rio e no terreno Estrada, os 
obst&#225;culos podem se mover numa determinada dire&#231;&#227;o, ent&#227;o a ordem dos obst&#225;culos pode mudar na lista de obst&#225;culos. Assim, para al&#233;m de garantirmos que n&#227;o existem 6 troncos seguidos ou 4
carros seguidos na lista de obst&#225;culos, tamb&#233;m temos de garantir que se juntarmos o final da lista com o inicio da lista tamb&#233;m n&#227;o existem 6 troncos seguidos ou 4 carros seguidos na lista
de obst&#225;culos. </p><p>Para verificar isto, decidi duplicar a lista de obst&#225;culos, ou seja, juntar a lista de obst&#225;culos &#224; pr&#243;pria lista de obst&#225;culos atrav&#233;s da fun&#231;&#227;o (++) pr&#233;-definida do Haskell. Para isso 
usei a fun&#231;&#227;o recursiva <code><a href="Tarefa1_2022li1g030.html#v:duplicarListaObstaculos" title="Tarefa1_2022li1g030">duplicarListaObstaculos</a></code>, que recebe e retorna uma lista de pares de terrenos e de listas de obst&#225;culos, que pode ser definida da seguinte forma:</p><pre>duplicarListaObstaculos ((ter,l):t) = (ter,l ++ l): duplicarListaObstaculos t
duplicarListaObstaculos [] = []
</pre></div></div><div class="top"><p class="src"><a id="v:mapaListaObstaculosDuplicados" class="def">mapaListaObstaculosDuplicados</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> <a href="#v:mapaListaObstaculosDuplicados" class="selflink">#</a></p><div class="doc"><p>Depois usei a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:mapaListaObstaculosDuplicados" title="Tarefa1_2022li1g030">mapaListaObstaculosDuplicados</a></code>, que recebe um mapa e retorna um mapa, e que obt&#233;m o mapa com as listas de obst&#225;culos duplicados. Esta fun&#231;&#227;o utiliza a fun&#231;&#227;o 
anterior (<code><a href="Tarefa1_2022li1g030.html#v:duplicarListaObstaculos" title="Tarefa1_2022li1g030">duplicarListaObstaculos</a></code>) e pode ser definida da seguinte forma:</p><pre>mapaListaObstaculosDuplicados (Mapa n l) = (Mapa n (duplicarListaObstaculos l))
</pre></div></div><div class="top"><p class="src"><a id="v:compMaxObstaculos" class="def">compMaxObstaculos</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool <a href="#v:compMaxObstaculos" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:compMaxObstaculos" title="Tarefa1_2022li1g030">compMaxObstaculos</a></code>, que recebe um mapa e retorna um bool, verifica se num dado mapa os troncos t&#234;m comprimento m&#225;ximo de 5 unidades e os carros t&#234;m comprimento m&#225;ximo de 3 
unidades. Se a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:compMaxObstaculos" title="Tarefa1_2022li1g030">compMaxObstaculos</a></code> receber o mapa resultante da fun&#231;&#227;o anterior (<code><a href="Tarefa1_2022li1g030.html#v:mapaListaObstaculosDuplicados" title="Tarefa1_2022li1g030">mapaListaObstaculosDuplicados</a></code>), ent&#227;o ser&#225; poss&#237;vel verificar se no mapa original (n&#227;o duplicado)
os troncos t&#234;m comprimento m&#225;ximo de 5 unidades e os carros t&#234;m comprimento m&#225;ximo de 3 unidades.</p><p>Para os troncos terem comprimento m&#225;ximo de 5 unidades e os carros comprimento m&#225;ximo de 3 unidades, ent&#227;o numa lista de obst&#225;culos n&#227;o podem existir 6 troncos seguidos ou 4 carros
seguidos. Se houver 6 troncos seguidos ou 4 carros seguidos ent&#227;o a fun&#231;&#227;o retorna False. Se isso n&#227;o acontecer, ent&#227;o a fun&#231;&#227;o ir&#225; chamar a ela mesma (fun&#231;&#227;o recursiva) para verificar se
n&#227;o h&#225; 6 troncos seguidos ou 4 carros seguidos na pr&#243;xima lista de obst&#225;culos. Quando a fun&#231;&#227;o percorrer todo o mapa e n&#227;o encontrar 6 troncos seguidos ou 4 carros seguidos em nenhuma das
listas de obst&#225;culos e quando apenas sobrar a lista vazia, a fun&#231;&#227;o ir&#225; retornar True.</p><p>Assim, a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:compMaxObstaculos" title="Tarefa1_2022li1g030">compMaxObstaculos</a></code> pode ser definida da seguinte forma:</p><pre>compMaxObstaculos (Mapa n ((_,(Tronco:Tronco:Tronco:Tronco:Tronco:Tronco:t1)):t)) = False
compMaxObstaculos (Mapa n ((_,(Carro:Carro:Carro:Carro:t1)):t)) = False
compMaxObstaculos (Mapa n ((ter,(_:t1)):t)) = compMaxObstaculos (Mapa n ((ter,t1):t))
compMaxObstaculos (Mapa n ((_,[]):t)) = compMaxObstaculos (Mapa n t)
compMaxObstaculos (Mapa n []) = True
</pre></div></div><div class="top"><p class="src"><a id="v:umNenhumNoMinimo" class="def">umNenhumNoMinimo</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool <a href="#v:umNenhumNoMinimo" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:umNenhumNoMinimo" title="Tarefa1_2022li1g030">umNenhumNoMinimo</a></code>, que recebe um mapa e retorna um bool, verifica se um dado mapa tem em todas as listas de obst&#225;culos n&#227;o vazias, no m&#237;nimo, um obst&#225;culo Nenhum. Esta fun&#231;&#227;o
percorre toda a lista de obst&#225;culos &#225; procura de um obst&#225;culo Nenhum, atraves da fun&#231;&#227;o elem pr&#233;-definida no Haskell. Se Nenhum n&#227;o for elemento da lista, ou seja, se elem Nenhum l &#233; False
ent&#227;o a fun&#231;&#227;o umNenhumNoMinimo retornara False. Se Nenhum for elemento da lista, ou seja, se elem Nenhum l &#233; True ent&#227;o a fun&#231;&#227;o ir&#225; chamar a ela mesma (fun&#231;&#227;o recursiva) para verificar 
se Nenhum &#233; elemento da pr&#243;xima lista de obst&#225;culos. Quando a fun&#231;&#227;o tiver percorrido todas as listas de obst&#225;culos do Mapa e encontrar no m&#237;nimo um obst&#225;culo Nenhum em todas elas e quando
apenas sobrar a lista vazia, a fun&#231;&#227;o ir&#225; retornar True.</p><p>Assim, a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:umNenhumNoMinimo" title="Tarefa1_2022li1g030">umNenhumNoMinimo</a></code> pode ser definida da seguinte forma:</p><pre>umNenhumNoMinimo (Mapa n ((_,l):t)) | elem Nenhum l == True = umNenhumNoMinimo (Mapa n t)
                                    | otherwise = False
umNenhumNoMinimo (Mapa n []) = True
</pre></div></div><div class="top"><p class="src"><a id="v:larguraCompObstaculos" class="def">larguraCompObstaculos</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool <a href="#v:larguraCompObstaculos" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:larguraCompObstaculos" title="Tarefa1_2022li1g030">larguraCompObstaculos</a></code>, que recebe um mapa e retorna um bool, verifica se num dado mapa a largura do mapa &#233; igual ao comprimento de todas as listas de obst&#225;culos. Esta fun&#231;&#227;o
calcula o comprimeto da lista de obst&#225;culos atrav&#233;s da fun&#231;&#227;o length pr&#233;-definida no Haskel e verifica se esse valor &#233; igual &#225; largura do mapa. Se n&#227;o for igual, a fun&#231;&#227;o retornara False.
Se for igual, ent&#227;o a fun&#231;&#227;o ir&#225; chamar a ela mesma (fun&#231;&#227;o recursiva) para calcular o comprimento da pr&#243;xima lista de obst&#225;culos  e comparar esse valor com a largura do mapa. Quando a 
fun&#231;&#227;o tiver percorrido todas as listas de obst&#225;culos do Mapa sem encontrar nenhuma lista de comprimento diferente &#224; largura e quando apenas sobrar a lista vazia, a fun&#231;&#227;o ir&#225; retornar 
True.</p><p>Assim, a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:larguraCompObstaculos" title="Tarefa1_2022li1g030">larguraCompObstaculos</a></code> pode ser definida da seguinte forma:</p><pre>larguraCompObstaculos (Mapa n ((_,l):t)) | n == length l = larguraCompObstaculos (Mapa n t)
                                         | otherwise = False
larguraCompObstaculos (Mapa n []) = True
</pre></div></div><div class="top"><p class="src"><a id="v:maxTerrenoContiguo" class="def">maxTerrenoContiguo</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool <a href="#v:maxTerrenoContiguo" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:maxTerrenoContiguo" title="Tarefa1_2022li1g030">maxTerrenoContiguo</a></code>, que recebe um mapa e retorna um bool, verifica se num dado mapa n&#227;o existem cont&#237;guamente mais do que 4 rios, nem 5 estradas ou relvas. Esta fun&#231;&#227;o
verifica que os 5 primeiros terrenos n&#227;o s&#227;o todos Rio e que os 6 primeiros terrenos n&#227;o s&#227;o todos Estrada ou Relva. Se fossem, ent&#227;o a fun&#231;&#227;o retornaria False. Se n&#227;o fossem, ent&#227;o
a fun&#231;&#227;o ir&#225; chamar a ela mesma (fun&#231;&#227;o recursiva) para verificar que os pr&#243;ximos 5 terrenos n&#227;o s&#227;o todos Rio ou que os pr&#243;ximos 6 terrenos n&#227;o s&#227;o todos Estrada ou Relva. Quando a fun&#231;&#227;o
percorrer toda a lista do mapa sendo que n&#227;o existem cont&#237;guamente mais do que 4 rios, nem 5 estradas ou relvas, e quando apenas sobrar a lista vazia, a fun&#231;&#227;o ir&#225; retornar True.</p><p>Assim, a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:maxTerrenoContiguo" title="Tarefa1_2022li1g030">maxTerrenoContiguo</a></code> pode ser definida da seguinte forma:</p><pre>maxTerrenoContiguo (Mapa n ((Rio n1,l1):(Rio n2,l2):(Rio n3,l3):(Rio n4,l4):(Rio n5,l5):t)) = False
maxTerrenoContiguo (Mapa n ((Estrada n1,l1):(Estrada n2,l2):(Estrada n3,l3):(Estrada n4,l4):(Estrada n5,l5):(Estrada n6,l6):t)) = False
maxTerrenoContiguo (Mapa n ((Relva,l1):(Relva,l2):(Relva,l3):(Relva,l4):(Relva,l5):(Relva,l6):t)) = False
maxTerrenoContiguo (Mapa n (h:t)) = maxTerrenoContiguo (Mapa n t)
maxTerrenoContiguo (Mapa n []) = True
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>