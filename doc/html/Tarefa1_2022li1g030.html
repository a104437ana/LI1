<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Tarefa1_2022li1g030</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption empty">&nbsp;</span><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>Ana S&#225; Oliveira &lt;a104437@alunos.uminho.pt&gt;<br />Sara Campos Ramalho &lt;a72481@alunos.uminho.pt&gt;</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr></table><p class="caption">Tarefa1_2022li1g030</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Fun&#231;&#227;o mapaValido</a><ul><li><a href="#g:2">Fun&#231;&#227;o principal</a></li><li><a href="#g:3">Fun&#231;&#245;es auxiliares</a></li></ul></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>M&#243;dulo para a realiza&#231;&#227;o da Tarefa 1 do projeto de LI1 em 2022/23.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:mapaValido">mapaValido</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool</li><li class="src short"><a href="#v:obstaculoTerrenoProprioMapa">obstaculoTerrenoProprioMapa</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool</li><li class="src short"><a href="#v:obstaculoTerrenoProprioLinha">obstaculoTerrenoProprioLinha</a> :: (<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>]) -&gt; Bool</li><li class="src short"><a href="#v:riosDirecaoOposta">riosDirecaoOposta</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool</li><li class="src short"><a href="#v:duplicarListaObstaculos">duplicarListaObstaculos</a> :: [(<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>])] -&gt; [(<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>])]</li><li class="src short"><a href="#v:mapaListaObstaculosDuplicados">mapaListaObstaculosDuplicados</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a></li><li class="src short"><a href="#v:compMaxObstaculos">compMaxObstaculos</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool</li><li class="src short"><a href="#v:umNenhumNoMinimo">umNenhumNoMinimo</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool</li><li class="src short"><a href="#v:larguraCompObstaculos">larguraCompObstaculos</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool</li><li class="src short"><a href="#v:maxTerrenoContiguo">maxTerrenoContiguo</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Fun&#231;&#227;o mapaValido</h1></a><a href="#g:2" id="g:2"><h2>Fun&#231;&#227;o principal</h2></a><div class="top"><p class="src"><a id="v:mapaValido" class="def">mapaValido</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool <a href="#v:mapaValido" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:mapaValido" title="Tarefa1_2022li1g030">mapaValido</a></code>, que recebe um mapa e retorna um bool, verifica se um dado mapa &#233; v&#225;lido, ou seja, se um dado mapa n&#227;o viola nenhuma das seguintes restri&#231;&#245;es:</p><ul><li>N&#227;o existem obst&#225;culos em terrenos impr&#243;prios (por exemplo, troncos em estradas ou relvas, &#225;rvores em rios ou estradas, etc.);</li><li>Rios cont&#237;guos t&#234;m dire&#231;&#245;es opostas;</li><li>Troncos t&#234;m, no m&#225;ximo, 5 unidades de comprimento;</li><li>Carros t&#234;m, no m&#225;ximo, 3 unidades de comprimento;</li><li>Em qualquer linha existe, no m&#237;nimo, um &#8220;obst&#225;culo&quot; Nenhum, ou seja, uma linha n&#227;o pode ser composta exclusivamente por obst&#225;culos, precisando de haver pelo menos um espa&#231;o livre;</li><li>O comprimento da lista de obst&#225;culos de cada linha corresponde exatamente &#224; largura do mapa;</li><li>Contiguamente, n&#227;o devem existir mais do que 4 rios, nem 5 estradas ou relvas.</li></ul><p>A fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:mapaValido" title="Tarefa1_2022li1g030">mapaValido</a></code> pode ser definida em fun&#231;&#227;o de outras fun&#231;&#245;es auxiliares: a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:obstaculoTerrenoProprioMapa" title="Tarefa1_2022li1g030">obstaculoTerrenoProprioMapa</a></code>, a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:riosDirecaoOposta" title="Tarefa1_2022li1g030">riosDirecaoOposta</a></code>, a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:compMaxObstaculos" title="Tarefa1_2022li1g030">compMaxObstaculos</a></code>, a fun&#231;&#227;o
<code><a href="Tarefa1_2022li1g030.html#v:umNenhumNoMinimo" title="Tarefa1_2022li1g030">umNenhumNoMinimo</a></code>, a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:larguraCompObstaculos" title="Tarefa1_2022li1g030">larguraCompObstaculos</a></code> e a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:maxTerrenoContiguo" title="Tarefa1_2022li1g030">maxTerrenoContiguo</a></code>, fun&#231;&#245;es que recebem um mapa e retornam um bool e que verificam as restri&#231;&#245;es anteriormente enunciadas. </p><p>Se uma destas fun&#231;&#245;es auxiliares retornar False, ou seja, se uma das restri&#231;&#245;es n&#227;o for respeitada, ent&#227;o automaticamente o mapa ser&#225; inv&#225;lido, ou seja, a fun&#231;&#227;o mapaValido ir&#225; retornar
False. Assim, para o mapa ser v&#225;lido, ou seja, para a fun&#231;&#227;o mapaValido retornar True, ent&#227;o todas as restri&#231;&#245;es ter&#227;o de ser respeitadas, logo todas as fun&#231;&#245;es auxiliares ter&#227;o de
retornar True.</p><p>Assim, a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:mapaValido" title="Tarefa1_2022li1g030">mapaValido</a></code> pode ser definida da seguinte forma:</p><pre>mapaValido m = 
    obstaculoTerrenoProprioMapa m &amp;&amp; 
    riosDirecaoOposta m &amp;&amp; 
    compMaxObstaculos (mapaListaObstaculosDuplicados m) &amp;&amp; 
    umNenhumNoMinimo m &amp;&amp; 
    larguraCompObstaculos m &amp;&amp; 
    maxTerrenoContiguo m
</pre><p>A fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:mapaValido" title="Tarefa1_2022li1g030">mapaValido</a></code> cont&#233;m ainda outra fun&#231;&#227;o auxiliar, a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:mapaListaObstaculosDuplicados" title="Tarefa1_2022li1g030">mapaListaObstaculosDuplicados</a></code> que por sua vez cont&#233;m outra fun&#231;&#227;o auxiliar, a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:duplicarListaObstaculos" title="Tarefa1_2022li1g030">duplicarListaObstaculos</a></code>.</p><p>Por fim, a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:obstaculoTerrenoProprioMapa" title="Tarefa1_2022li1g030">obstaculoTerrenoProprioMapa</a></code> cont&#233;m ainda uma fun&#231;&#227;o auxiliar, a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:obstaculoTerrenoProprioLinha" title="Tarefa1_2022li1g030">obstaculoTerrenoProprioLinha</a></code>.</p></div></div><a href="#g:3" id="g:3"><h2>Fun&#231;&#245;es auxiliares</h2></a><div class="top"><p class="src"><a id="v:obstaculoTerrenoProprioMapa" class="def">obstaculoTerrenoProprioMapa</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool <a href="#v:obstaculoTerrenoProprioMapa" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:obstaculoTerrenoProprioMapa" title="Tarefa1_2022li1g030">obstaculoTerrenoProprioMapa</a></code>, que recebe um mapa e retorna um bool, verifica se num dado mapa n&#227;o existem obst&#225;culos em terrenos impr&#243;prios, ou seja, verifica que n&#227;o existem 
Troncos em Estradas ou Relvas, que n&#227;o existem Carros em Rios ou Relvas e que n&#227;o existem Arvores em Rios ou Estradas.</p><p>Para esta fun&#231;&#227;o retornar True, ent&#227;o todos os elementos da lista do mapa (todas as linhas do mapa) ter&#227;o de satisfazer uma condi&#231;&#227;o (devido a fun&#231;&#227;o all), condi&#231;&#227;o essa, definida na 
fun&#231;&#227;o auxiliar <code><a href="Tarefa1_2022li1g030.html#v:obstaculoTerrenoProprioLinha" title="Tarefa1_2022li1g030">obstaculoTerrenoProprioLinha</a></code> que iremos ver a seguir. Se a lista do mapa for vazia a fun&#231;&#227;o tamb&#233;m retorna True e se nem todos os elementos da lista satisfazerem a tal 
condi&#231;&#227;o, ent&#227;o a fun&#231;&#227;o ir&#225; retornar False.</p><p>Assim, a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:obstaculoTerrenoProprioMapa" title="Tarefa1_2022li1g030">obstaculoTerrenoProprioMapa</a></code> pode ser definida da seguinte forma:</p><pre>obstaculoTerrenoProprioMapa (Mapa _ l) = if l == [] then True
                                         else all obstaculoTerrenoProprioLinha l
</pre></div></div><div class="top"><p class="src"><a id="v:obstaculoTerrenoProprioLinha" class="def">obstaculoTerrenoProprioLinha</a> :: (<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>]) -&gt; Bool <a href="#v:obstaculoTerrenoProprioLinha" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:obstaculoTerrenoProprioLinha" title="Tarefa1_2022li1g030">obstaculoTerrenoProprioLinha</a></code>, que recebe uma lista de pares de terrenos e de listas de obst&#225;culos (uma linha do mapa) e que retorna um bool, verifica se numa linha do mapa
n&#227;o existem obst&#225;culos impr&#243;prios para o terreno dessa linha. </p><p>Se o terreno for Rio, ent&#227;o sabemos que n&#227;o pode existir na lista nem um carro nem uma &#225;rvore. Se o terreno for Estrada, ent&#227;o sabemos que n&#227;o pode existir na lista nem um tronco nem uma 
&#225;rvore. Se o terreno for Relva, ent&#227;o sabemos que n&#227;o pode existir na lista nem um tronco nem um carro. Para verificar estas condi&#231;&#245;es usamos a fun&#231;&#227;o auxiliar pr&#233;-definida no Haskell, 
notElem, que praticamente faz o oposto da fun&#231;&#227;o elem, ou seja, verifica se algo n&#227;o pertence &#224; lista. Se o obst&#225;culo imp&#341;&#243;prio a um terreno n&#227;o pertencer &#224; lista desse terreno (mapa 
v&#225;lido), ent&#227;o a fun&#231;&#227;o retorna True. Se obst&#225;culo imp&#341;&#243;prio a um terreno pertencer &#224; lista desse terreno (mapa inv&#225;lido), ent&#227;o a fun&#231;&#227;o retorna False.</p><p>Assim, a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:obstaculoTerrenoProprioLinha" title="Tarefa1_2022li1g030">obstaculoTerrenoProprioLinha</a></code> pode ser definida da seguinte forma:</p><pre>obstaculoTerrenoProprioLinha (ter,lo) = 
    case ter of Rio _ -&gt; notElem Carro lo &amp;&amp; notElem Arvore lo
                Estrada _ -&gt; notElem Tronco lo &amp;&amp; notElem Arvore lo
                Relva -&gt; notElem Tronco lo &amp;&amp; notElem Carro lo
</pre></div></div><div class="top"><p class="src"><a id="v:riosDirecaoOposta" class="def">riosDirecaoOposta</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool <a href="#v:riosDirecaoOposta" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:riosDirecaoOposta" title="Tarefa1_2022li1g030">riosDirecaoOposta</a></code>, que recebe um mapa e retorna um bool, verifica se num dado mapa rios cont&#237;guos apresentam dire&#231;&#245;es opostas, ou seja, verifica se rios cont&#237;guos apresentam
velocidades de sinal oposto (por exemplo, o primeiro rio com velocidade positiva e o segundo rio cont&#237;guo ao primeiro com velocidade negativa ou vice-versa). Se isso n&#227;o se verificar, a 
fun&#231;&#227;o retorna False. Se isso se verificar, ent&#227;o a fun&#231;&#227;o ir&#225; chamar a ela mesma (fun&#231;&#227;o recursiva) para verificar se o segundo rio tem dire&#231;&#227;o oposta do terceiro ou se ap&#243;s o segundo rio
existe um terreno diferente de rio. Quando a fun&#231;&#227;o percorrer todo o mapa e n&#227;o encontrar nenhuns rios cont&#237;guos com dire&#231;&#245;es opostas e quando apenas sobrar a lista vazia ou uma lista de 
um elemento, a fun&#231;&#227;o ir&#225; retornar True.</p><p>Nota : iremos considerar que rios cont&#237;guos com velocidade igual a 0, ou rios cont&#237;guos em que apenas um tem velocidade igual a 0, s&#227;o rios de dire&#231;&#245;es opostas.</p><p>Assim, a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:riosDirecaoOposta" title="Tarefa1_2022li1g030">riosDirecaoOposta</a></code> pode ser definida da seguinte forma:</p><pre>riosDirecaoOposta (Mapa n l) = 
    case l of ((Rio v1,_):(Rio v2,lo2):t) | v1&gt;=0 &amp;&amp; v2<a href="=0">-</a> riosDirecaoOposta (Mapa n ((Rio v2,lo2):t))
                                          | v1<a href="=0">&amp;&amp; v2</a>=0 -&gt; riosDirecaoOposta (Mapa n ((Rio 2,lo2):t))
                                          | otherwise -&gt; False 
              ((_,_):(Rio v2,lo2):t) -&gt; riosDirecaoOposta (Mapa n ((Rio v2,lo2):t))
              ((_,_):(_,_):t) -&gt; riosDirecaoOposta (Mapa n t)
              [(_,_)] -&gt; True
              [] -&gt; True
</pre></div></div><div class="top"><p class="src"><a id="v:duplicarListaObstaculos" class="def">duplicarListaObstaculos</a> :: [(<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>])] -&gt; [(<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>])] <a href="#v:duplicarListaObstaculos" class="selflink">#</a></p><div class="doc"><p>Queremos verificar se num dado mapa os troncos t&#234;m comprimento m&#225;ximo de 5 unidades e os carros t&#234;m comprimento m&#225;ximo de 3 unidades. Como no terreno Rio e no terreno Estrada, os 
obst&#225;culos podem se mover numa determinada dire&#231;&#227;o, ent&#227;o a ordem dos obst&#225;culos pode mudar na lista de obst&#225;culos. Assim, para al&#233;m de garantirmos que n&#227;o existem 6 troncos seguidos ou 4
carros seguidos na lista de obst&#225;culos, tamb&#233;m temos de garantir que se juntarmos o final da lista com o inicio da lista tamb&#233;m n&#227;o existem 6 troncos seguidos ou 4 carros seguidos na lista
de obst&#225;culos. </p><p>Para verificar isto, decidi duplicar a lista de obst&#225;culos, ou seja, juntar a lista de obst&#225;culos &#224; pr&#243;pria lista de obst&#225;culos atrav&#233;s da fun&#231;&#227;o (++) pr&#233;-definida do Haskell. Para isso 
usei a fun&#231;&#227;o recursiva <code><a href="Tarefa1_2022li1g030.html#v:duplicarListaObstaculos" title="Tarefa1_2022li1g030">duplicarListaObstaculos</a></code>, que recebe e retorna uma lista de pares de terrenos e de listas de obst&#225;culos (a lista do mapa), que pode ser definida da seguinte forma:</p><pre>duplicarListaObstaculos l = 
    case l of [] -&gt; []
              ((ter,lo):t) -&gt; (ter,lo ++ lo): duplicarListaObstaculos t
</pre><p>Nota : <a href="Duplicar.html">Duplicar</a> a lista dos obst&#225;culos para verificar o comprimento m&#225;ximo dos obst&#225;culos apenas poderia trazer problemas numa linha com 5 troncos apenas ou numa linha com 3 carros 
apenas. Nestes casos, o comprimento dos obst&#225;culos &#233; v&#225;lido mas utilizando a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:duplicarListaObstaculos" title="Tarefa1_2022li1g030">duplicarListaObstaculos</a></code>, esta ir&#225; construir uma linha em que o comprimento dos obst&#225;culos &#233; inv&#225;lido
(10 troncos seguidos ou ent&#227;o 6 carros seguidos). No entanto, podemos descartar este problema porque para o mapa ser v&#225;lido, tem de existir sempre pelo menos um Nenhum em todas as linhas
(condi&#231;&#227;o garantida pela fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:umNenhumNoMinimo" title="Tarefa1_2022li1g030">umNenhumNoMinimo</a></code> que iremos definir posteriormente). Por esta raz&#227;o, podemos &quot;duplicar&quot; a lista de obst&#225;culos sem preocupa&#231;&#245;es. </p></div></div><div class="top"><p class="src"><a id="v:mapaListaObstaculosDuplicados" class="def">mapaListaObstaculosDuplicados</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> <a href="#v:mapaListaObstaculosDuplicados" class="selflink">#</a></p><div class="doc"><p>Depois usei a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:mapaListaObstaculosDuplicados" title="Tarefa1_2022li1g030">mapaListaObstaculosDuplicados</a></code>, que recebe um mapa (o mapa original) e retorna um mapa (o mapa com as listas de obst&#225;culos duplicados). Esta fun&#231;&#227;o utiliza a 
fun&#231;&#227;o anterior (<code><a href="Tarefa1_2022li1g030.html#v:duplicarListaObstaculos" title="Tarefa1_2022li1g030">duplicarListaObstaculos</a></code>) e pode ser definida da seguinte forma:</p><pre>mapaListaObstaculosDuplicados (Mapa n l) = (Mapa n (duplicarListaObstaculos l))
</pre></div></div><div class="top"><p class="src"><a id="v:compMaxObstaculos" class="def">compMaxObstaculos</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool <a href="#v:compMaxObstaculos" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:compMaxObstaculos" title="Tarefa1_2022li1g030">compMaxObstaculos</a></code>, que recebe um mapa e retorna um bool, verifica se num dado mapa os troncos t&#234;m comprimento m&#225;ximo de 5 unidades e os carros t&#234;m comprimento m&#225;ximo de 3 
unidades. Se a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:compMaxObstaculos" title="Tarefa1_2022li1g030">compMaxObstaculos</a></code> receber o mapa resultante da fun&#231;&#227;o anterior <code><a href="Tarefa1_2022li1g030.html#v:mapaListaObstaculosDuplicados" title="Tarefa1_2022li1g030">mapaListaObstaculosDuplicados</a></code>, ou seja, se receber o mapa com as listas de obst&#225;culos duplicados,
ent&#227;o ser&#225; poss&#237;vel verificar se no mapa original (n&#227;o duplicado) os troncos t&#234;m comprimento m&#225;ximo de 5 unidades e os carros t&#234;m comprimento m&#225;ximo de 3 unidades.</p><p>Para os troncos terem comprimento m&#225;ximo de 5 unidades e os carros comprimento m&#225;ximo de 3 unidades, ent&#227;o numa lista de obst&#225;culos n&#227;o podem existir 6 troncos seguidos ou 4 carros
seguidos. Se houver 6 troncos seguidos ou 4 carros seguidos ent&#227;o a fun&#231;&#227;o retorna False. Se isso n&#227;o acontecer, ent&#227;o a fun&#231;&#227;o ir&#225; chamar a ela mesma (fun&#231;&#227;o recursiva) para verificar se
n&#227;o h&#225; 6 troncos seguidos ou 4 carros seguidos na pr&#243;xima lista de obst&#225;culos (na pr&#243;xima linha). Quando a fun&#231;&#227;o percorrer todo o mapa e n&#227;o encontrar 6 troncos seguidos ou 4 carros 
seguidos em nenhuma das listas de obst&#225;culos (em nenhuma das linhas do mapa) e quando apenas sobrar a lista vazia, a fun&#231;&#227;o ir&#225; retornar True.</p><p>Assim, a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:compMaxObstaculos" title="Tarefa1_2022li1g030">compMaxObstaculos</a></code> pode ser definida da seguinte forma:</p><pre>compMaxObstaculos (Mapa n l) = 
    case l of ((_,(Tronco:Tronco:Tronco:Tronco:Tronco:Tronco:_)):_) -&gt; False
              ((_,(Carro:Carro:Carro:Carro:_)):_) -&gt; False
              ((ter,(_:t1)):t) -&gt; compMaxObstaculos (Mapa n ((ter,t1):t))
              ((_,[]):t) -&gt; compMaxObstaculos (Mapa n t)
              [] -&gt; True
</pre></div></div><div class="top"><p class="src"><a id="v:umNenhumNoMinimo" class="def">umNenhumNoMinimo</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool <a href="#v:umNenhumNoMinimo" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:umNenhumNoMinimo" title="Tarefa1_2022li1g030">umNenhumNoMinimo</a></code>, que recebe um mapa e retorna um bool, verifica se um dado mapa tem em todas as listas de obst&#225;culos n&#227;o vazias, no m&#237;nimo, um obst&#225;culo Nenhum. Esta fun&#231;&#227;o
percorre toda a lista de obst&#225;culos (toda a linha) &#225; procura de um obst&#225;culo Nenhum, atrav&#233;s da fun&#231;&#227;o elem pr&#233;-definida no Haskell. Se Nenhum n&#227;o for elemento da lista, ou seja, se 
elem Nenhum l &#233; False ent&#227;o a fun&#231;&#227;o umNenhumNoMinimo retornara False. Se Nenhum for elemento da lista, ou seja, se elem Nenhum l &#233; True ent&#227;o a fun&#231;&#227;o ir&#225; chamar a ela mesma (fun&#231;&#227;o 
recursiva) para verificar se Nenhum &#233; elemento da pr&#243;xima lista de obst&#225;culos. Quando a fun&#231;&#227;o tiver percorrido todas as listas de obst&#225;culos do Mapa (todas as linhas do mapa) e encontrar
no m&#237;nimo um obst&#225;culo Nenhum em todas elas e quando apenas sobrar a lista vazia, a fun&#231;&#227;o ir&#225; retornar True.</p><p>Assim, a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:umNenhumNoMinimo" title="Tarefa1_2022li1g030">umNenhumNoMinimo</a></code> pode ser definida da seguinte forma:</p><pre>umNenhumNoMinimo (Mapa n l) = 
    case l of [] -&gt; True
              ((_,lo):t) -&gt; if elem Nenhum lo then umNenhumNoMinimo (Mapa n t)
                            else False
</pre></div></div><div class="top"><p class="src"><a id="v:larguraCompObstaculos" class="def">larguraCompObstaculos</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool <a href="#v:larguraCompObstaculos" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:larguraCompObstaculos" title="Tarefa1_2022li1g030">larguraCompObstaculos</a></code>, que recebe um mapa e retorna um bool, verifica se num dado mapa a largura do mapa &#233; igual ao comprimento de todas as listas de obst&#225;culos. Esta fun&#231;&#227;o
calcula o comprimeto da lista de obst&#225;culos (o comprimento da linha) atrav&#233;s da fun&#231;&#227;o length pr&#233;-definida no Haskel e verifica se esse valor &#233; igual &#225; largura do mapa. Se n&#227;o for igual, a
fun&#231;&#227;o retornara False. Se for igual, ent&#227;o a fun&#231;&#227;o ir&#225; chamar a ela mesma (fun&#231;&#227;o recursiva) para calcular o comprimento da pr&#243;xima lista de obst&#225;culos  e comparar esse valor com a 
largura do mapa. Quando a fun&#231;&#227;o tiver percorrido todas as listas de obst&#225;culos do Mapa (todas as linhas do mapa) sem encontrar nenhuma lista de comprimento diferente &#224; largura e quando 
apenas sobrar a lista vazia, a fun&#231;&#227;o ir&#225; retornar True.</p><p>Assim, a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:larguraCompObstaculos" title="Tarefa1_2022li1g030">larguraCompObstaculos</a></code> pode ser definida da seguinte forma:</p><pre>larguraCompObstaculos (Mapa n l) = 
    case l of [] -&gt; True
              ((_,lo):t) -&gt; if n == length lo then larguraCompObstaculos (Mapa n t)
                            else False
</pre></div></div><div class="top"><p class="src"><a id="v:maxTerrenoContiguo" class="def">maxTerrenoContiguo</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool <a href="#v:maxTerrenoContiguo" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:maxTerrenoContiguo" title="Tarefa1_2022li1g030">maxTerrenoContiguo</a></code>, que recebe um mapa e retorna um bool, verifica se num dado mapa n&#227;o existem cont&#237;guamente mais do que 4 rios, nem 5 estradas ou relvas. Esta fun&#231;&#227;o
verifica que os 5 primeiros terrenos n&#227;o s&#227;o todos Rio e que os 6 primeiros terrenos n&#227;o s&#227;o todos Estrada ou Relva. Se fossem, ent&#227;o a fun&#231;&#227;o retornaria False. Se n&#227;o fossem, ent&#227;o
a fun&#231;&#227;o ir&#225; chamar a ela mesma (fun&#231;&#227;o recursiva) para verificar que os pr&#243;ximos 5 terrenos n&#227;o s&#227;o todos Rio ou que os pr&#243;ximos 6 terrenos n&#227;o s&#227;o todos Estrada ou Relva. Quando a fun&#231;&#227;o
percorrer toda a lista do mapa sendo que n&#227;o existem cont&#237;guamente mais do que 4 rios, nem 5 estradas ou relvas, e quando apenas sobrar a lista vazia, a fun&#231;&#227;o ir&#225; retornar True.</p><p>Assim, a fun&#231;&#227;o <code><a href="Tarefa1_2022li1g030.html#v:maxTerrenoContiguo" title="Tarefa1_2022li1g030">maxTerrenoContiguo</a></code> pode ser definida da seguinte forma:</p><pre>maxTerrenoContiguo (Mapa n l) = 
    case l of ((Rio _,_):(Rio _,_):(Rio _,_):(Rio _,_):(Rio _,_):_) -&gt; False
              ((Estrada _,_):(Estrada _,_):(Estrada _,_):(Estrada _,_):(Estrada _,_):(Estrada _,_):_) -&gt; False
              ((Relva,_):(Relva,_):(Relva,_):(Relva,_):(Relva,_):(Relva,_):_) -&gt; False
              (_:t) -&gt; maxTerrenoContiguo (Mapa n t)
              [] -&gt; True
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>